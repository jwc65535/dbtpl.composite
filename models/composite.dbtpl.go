package models

// Code generated by dbtpl. DO NOT EDIT.

import (
	"context"
	"database/sql"
)

// Composite is a composite type.
type Composite struct {
	TypeName string         `json:"type_name"`
	Comment  sql.NullString `json:"comment"`
}

// CompositeAttribute describes a composite attribute.
type CompositeAttribute struct {
	FieldOrdinal int            `json:"field_ordinal"`
	Attribute    string         `json:"attribute"`
	DataType     string         `json:"data_type"`
	NotNull      bool           `json:"not_null"`
	DefaultValue sql.NullString `json:"default_value"`
	Comment      sql.NullString `json:"comment"`
}

// PostgresComposites runs a custom query, returning results as [Composite].
func PostgresComposites(ctx context.Context, db DB, schema string) ([]*Composite, error) {
	// query
	const sqlstr = `SELECT ` +
		`t.typname, ` + // ::varchar AS type_name
		`COALESCE(d.description, '') ` + // ::varchar AS comment
		`FROM pg_type t ` +
		`JOIN ONLY pg_namespace n ON n.oid = t.typnamespace ` +
		`JOIN ONLY pg_class c ON c.oid = t.typrelid ` +
		`LEFT JOIN pg_description d ON d.objoid = t.oid ` +
		`AND d.objsubid = 0 ` +
		`WHERE t.typtype = 'c' ` +
		`AND n.nspname = $1 ` +
		`AND c.relkind = 'c'`
	// run
	logf(sqlstr, schema)
	rows, err := db.QueryContext(ctx, sqlstr, schema)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*Composite
	for rows.Next() {
		var c Composite
		// scan
		if err := rows.Scan(&c.TypeName, &c.Comment); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}

// PostgresCompositeAttributes runs a custom query, returning results as [CompositeAttribute].
func PostgresCompositeAttributes(ctx context.Context, db DB, schema, composite string) ([]*CompositeAttribute, error) {
	// query
	const sqlstr = `SELECT ` +
		`a.attnum AS field_ordinal, ` +
		`a.attname AS attribute, ` +
		`format_type(a.atttypid, a.atttypmod) AS data_type, ` +
		`a.attnotnull AS not_null, ` +
		`COALESCE(pg_get_expr(ad.adbin, ad.adrelid), '') AS default_value, ` +
		`COALESCE(d.description, '') AS comment ` +
		`FROM pg_attribute a ` +
		`JOIN ONLY pg_class c ON c.oid = a.attrelid ` +
		`JOIN ONLY pg_type t ON t.typrelid = c.oid ` +
		`JOIN ONLY pg_namespace n ON n.oid = t.typnamespace ` +
		`LEFT JOIN pg_attrdef ad ON ad.adrelid = a.attrelid ` +
		`AND ad.adnum = a.attnum ` +
		`LEFT JOIN pg_description d ON d.objoid = a.attrelid ` +
		`AND d.objsubid = a.attnum ` +
		`WHERE a.attisdropped = false ` +
		`AND a.attnum > 0 ` +
		`AND n.nspname = $1 ` +
		`AND t.typname = $2 ` +
		`AND c.relkind = 'c' ` +
		`ORDER BY a.attnum`
	// run
	logf(sqlstr, schema, composite)
	rows, err := db.QueryContext(ctx, sqlstr, schema, composite)
	if err != nil {
		return nil, logerror(err)
	}
	defer rows.Close()
	// load results
	var res []*CompositeAttribute
	for rows.Next() {
		var c CompositeAttribute
		// scan
		if err := rows.Scan(&c.FieldOrdinal, &c.Attribute, &c.DataType, &c.NotNull, &c.DefaultValue, &c.Comment); err != nil {
			return nil, logerror(err)
		}
		res = append(res, &c)
	}
	if err := rows.Err(); err != nil {
		return nil, logerror(err)
	}
	return res, nil
}
