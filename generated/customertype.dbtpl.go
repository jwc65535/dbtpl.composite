package generated

// Code generated by dbtpl. DO NOT EDIT.

import (
	"database/sql/driver"
	"fmt"
)

// CustomerType is the 'customer_type' enum type from schema 'public'.
type CustomerType uint16

// CustomerType values.
const (
	// CustomerTypeCommercial is the 'COMMERCIAL' customer_type.
	CustomerTypeCommercial CustomerType = 1
	// CustomerTypeResidential is the 'RESIDENTIAL' customer_type.
	CustomerTypeResidential CustomerType = 2
)

// String satisfies the [fmt.Stringer] interface.
func (ct CustomerType) String() string {
	switch ct {
	case CustomerTypeCommercial:
		return "COMMERCIAL"
	case CustomerTypeResidential:
		return "RESIDENTIAL"
	}
	return fmt.Sprintf("CustomerType(%d)", ct)
}

// MarshalText marshals [CustomerType] into text.
func (ct CustomerType) MarshalText() ([]byte, error) {
	return []byte(ct.String()), nil
}

// UnmarshalText unmarshals [CustomerType] from text.
func (ct *CustomerType) UnmarshalText(buf []byte) error {
	switch str := string(buf); str {
	case "COMMERCIAL":
		*ct = CustomerTypeCommercial
	case "RESIDENTIAL":
		*ct = CustomerTypeResidential
	default:
		return ErrInvalidCustomerType(str)
	}
	return nil
}

// Value satisfies the [driver.Valuer] interface.
func (ct CustomerType) Value() (driver.Value, error) {
	return ct.String(), nil
}

// Scan satisfies the [sql.Scanner] interface.
func (ct *CustomerType) Scan(v any) error {
	switch x := v.(type) {
	case []byte:
		return ct.UnmarshalText(x)
	case string:
		return ct.UnmarshalText([]byte(x))
	}
	return ErrInvalidCustomerType(fmt.Sprintf("%T", v))
}

// NullCustomerType represents a null 'customer_type' enum for schema 'public'.
type NullCustomerType struct {
	CustomerType CustomerType
	// Valid is true if [CustomerType] is not null.
	Valid bool
}

// Value satisfies the [driver.Valuer] interface.
func (nct NullCustomerType) Value() (driver.Value, error) {
	if !nct.Valid {
		return nil, nil
	}
	return nct.CustomerType.Value()
}

// Scan satisfies the [sql.Scanner] interface.
func (nct *NullCustomerType) Scan(v any) error {
	if v == nil {
		nct.CustomerType, nct.Valid = 0, false
		return nil
	}
	err := nct.CustomerType.Scan(v)
	nct.Valid = err == nil
	return err
}

// ErrInvalidCustomerType is the invalid [CustomerType] error.
type ErrInvalidCustomerType string

// Error satisfies the error interface.
func (err ErrInvalidCustomerType) Error() string {
	return fmt.Sprintf("invalid CustomerType(%s)", string(err))
}
