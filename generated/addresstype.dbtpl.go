// Package generated contains generated code for schema 'public'.
package generated

// Code generated by dbtpl. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
	"strings"
)

// AddressType is the 'address_type' composite type from schema 'public'.
type AddressType struct {
	StreetLine1 sql.NullString `json:"street_line1"` // street_line1
	StreetLine2 sql.NullString `json:"street_line2"` // street_line2
	City        sql.NullString `json:"city"`         // city
	ZipCode     sql.NullString `json:"zip_code"`     // zip_code
}

// NullAddressType represents a null 'address_type' composite for schema 'public'.
type NullAddressType struct {
	AddressType AddressType
	// Valid is true if [AddressType] is not null.
	Valid bool
}

// Value satisfies the [driver.Valuer] interface.
func (nat NullAddressType) Value() (driver.Value, error) {
	if !nat.Valid {
		return nil, nil
	}
	return atRecordLiteral(nat.AddressType)
}

// Scan satisfies the [sql.Scanner] interface.
func (nat *NullAddressType) Scan(v any) error {
	if v == nil {
		nat.AddressType, nat.Valid = AddressType{}, false
		return nil
	}
	if err := atScanRecord(v, &nat.AddressType); err != nil {
		return err
	}
	nat.Valid = true
	return nil
}

// AddressTypeArray represents a PostgreSQL array of 'address_type'.
type AddressTypeArray []AddressType

// Value satisfies the [driver.Valuer] interface.
func (ata AddressTypeArray) Value() (driver.Value, error) {
	if ata == nil {
		return nil, nil
	}
	parts := make([]string, len(ata))
	for i, elem := range ata {
		literal, err := atRecordLiteral(elem)
		if err != nil {
			return nil, err
		}
		escaped := strings.ReplaceAll(literal, `\\`, `\\\\`)
		escaped = strings.ReplaceAll(escaped, `"`, `\\"`)
		parts[i] = `"` + escaped + `"`
	}
	return "{" + strings.Join(parts, ",") + "}", nil
}

// Scan satisfies the [sql.Scanner] interface.
func (ata *AddressTypeArray) Scan(v any) error {
	if v == nil {
		*ata = nil
		return nil
	}
	var data string
	switch x := v.(type) {
	case []byte:
		data = string(x)
	case string:
		data = x
	default:
		return fmt.Errorf("cannot scan %T into AddressTypeArray", v)
	}
	elements, err := parseAddressTypeArray(data)
	if err != nil {
		return err
	}
	*ata = elements
	return nil
}

// MarshalJSON marshals [AddressType] to JSON.
func (at AddressType) MarshalJSON() ([]byte, error) {
	type alias AddressType
	return json.Marshal(alias(at))
}

// UnmarshalJSON unmarshals [AddressType] from JSON.
func (at *AddressType) UnmarshalJSON(data []byte) error {
	type alias AddressType
	return json.Unmarshal(data, (*alias)(at))
}

// Value satisfies the [driver.Valuer] interface.
func (at AddressType) Value() (driver.Value, error) {
	return atRecordLiteral(at)
}

// Scan satisfies the [sql.Scanner] interface.
func (at *AddressType) Scan(v any) error {
	if v == nil {
		*at = AddressType{}
		return nil
	}
	return atScanRecord(v, at)
}

// atRecordLiteral converts [AddressType] into a PostgreSQL composite literal.
func atRecordLiteral(at AddressType) (string, error) {
	parts := make([]string, 0, 4)

	fieldStreetLine1, err := encodeAddressTypeField(at.StreetLine1)
	if err != nil {
		return "", err
	}
	parts = append(parts, fieldStreetLine1)

	fieldStreetLine2, err := encodeAddressTypeField(at.StreetLine2)
	if err != nil {
		return "", err
	}
	parts = append(parts, fieldStreetLine2)

	fieldCity, err := encodeAddressTypeField(at.City)
	if err != nil {
		return "", err
	}
	parts = append(parts, fieldCity)

	fieldZipCode, err := encodeAddressTypeField(at.ZipCode)
	if err != nil {
		return "", err
	}
	parts = append(parts, fieldZipCode)

	return "(" + strings.Join(parts, ",") + ")", nil
}

// atScanRecord decodes a PostgreSQL composite literal into [AddressType].
func atScanRecord(v any, dest *AddressType) error {
	var record string
	switch x := v.(type) {
	case []byte:
		record = string(x)
	case string:
		record = x
	default:
		return fmt.Errorf("cannot scan %T into AddressType", v)
	}

	if strings.HasPrefix(record, "{") {
		return json.Unmarshal([]byte(record), dest)
	}

	fields, err := parseAddressTypeRecord(record, 4)
	if err != nil {
		return err
	}

	if err := scanAddressTypeField(&dest.StreetLine1, fields[0]); err != nil {
		return fmt.Errorf("AddressType.StreetLine1: %w", err)
	}

	if err := scanAddressTypeField(&dest.StreetLine2, fields[1]); err != nil {
		return fmt.Errorf("AddressType.StreetLine2: %w", err)
	}

	if err := scanAddressTypeField(&dest.City, fields[2]); err != nil {
		return fmt.Errorf("AddressType.City: %w", err)
	}

	if err := scanAddressTypeField(&dest.ZipCode, fields[3]); err != nil {
		return fmt.Errorf("AddressType.ZipCode: %w", err)
	}

	return nil
}

// parseAddressTypeArray converts a PostgreSQL array literal into its composite elements.
func parseAddressTypeArray(arrayLiteral string) ([]AddressType, error) {
	arrayLiteral = strings.TrimSpace(arrayLiteral)
	if arrayLiteral == "" || arrayLiteral == "{}" {
		return []AddressType{}, nil
	}
	if len(arrayLiteral) < 2 || arrayLiteral[0] != '{' || arrayLiteral[len(arrayLiteral)-1] != '}' {
		return nil, fmt.Errorf("invalid array format: %s", arrayLiteral)
	}

	inner := arrayLiteral[1 : len(arrayLiteral)-1]
	if inner == "" {
		return []AddressType{}, nil
	}

	rawElements := splitAddressTypeArrayElements(inner)
	result := make([]AddressType, 0, len(rawElements))
	for i, elem := range rawElements {
		elem = strings.TrimSpace(elem)
		if elem == "NULL" {
			result = append(result, AddressType{})
			continue
		}
		if strings.HasPrefix(elem, "\"") && strings.HasSuffix(elem, "\"") {
			elem = elem[1 : len(elem)-1]
			elem = strings.ReplaceAll(elem, `\\\"`, `\"`)
			elem = strings.ReplaceAll(elem, `\\\\`, `\\`)
		}

		var item AddressType
		if err := atScanRecord(elem, &item); err != nil {
			return nil, fmt.Errorf("element %d: %w", i, err)
		}
		result = append(result, item)
	}

	return result, nil
}

// splitAddressTypeArrayElements splits a PostgreSQL array inner literal into individual composite elements.
func splitAddressTypeArrayElements(s string) []string {
	var result []string
	var current strings.Builder
	depth := 0
	inQuote := false
	escaped := false

	for i := 0; i < len(s); i++ {
		ch := s[i]
		if escaped {
			current.WriteByte(ch)
			escaped = false
			continue
		}
		switch ch {
		case '\\':
			current.WriteByte(ch)
			escaped = true
			continue
		case '"':
			current.WriteByte(ch)
			inQuote = !inQuote
			continue
		case '(':
			if !inQuote {
				depth++
			}
		case ')':
			if !inQuote && depth > 0 {
				depth--
			}
		case ',':
			if !inQuote && depth == 0 {
				result = append(result, current.String())
				current.Reset()
				continue
			}
		}
		current.WriteByte(ch)
	}

	if current.Len() > 0 {
		result = append(result, current.String())
	}

	return result
}

// encodeAddressTypeField converts a value into a composite element literal.
func encodeAddressTypeField(v any) (string, error) {
	if valuer, ok := v.(driver.Valuer); ok {
		val, err := valuer.Value()
		if err != nil {
			return "", err
		}
		v = val
	}

	switch x := v.(type) {
	case nil:
		return "NULL", nil
	case string:
		return "\"" + escapeAddressTypeField(x) + "\"", nil
	case []byte:
		return "\"" + escapeAddressTypeField(string(x)) + "\"", nil
	default:
		b, err := json.Marshal(x)
		if err != nil {
			return "", err
		}
		return string(b), nil
	}
}

// scanAddressTypeField assigns a composite element into dst.
func scanAddressTypeField(dst any, src *string) error {
	if scanner, ok := dst.(sql.Scanner); ok {
		if src == nil {
			return scanner.Scan(nil)
		}
		return scanner.Scan(*src)
	}

	if src == nil {
		return nil
	}

	switch d := dst.(type) {
	case *string:
		*d = *src
		return nil
	default:
		return json.Unmarshal([]byte(*src), dst)
	}
}

// parseAddressTypeRecord splits a PostgreSQL composite literal into its fields.
func parseAddressTypeRecord(record string, expected int) ([]*string, error) {
	if len(record) < 2 || record[0] != '(' || record[len(record)-1] != ')' {
		return nil, fmt.Errorf("invalid record literal: %s", record)
	}

	record = record[1 : len(record)-1]
	fields := make([]*string, 0, expected)

	var buf strings.Builder
	inQuotes := false
	escaped := false
	quoted := false

	addField := func() {
		if !quoted && buf.String() == "NULL" {
			fields = append(fields, nil)
		} else {
			val := buf.String()
			fields = append(fields, &val)
		}
		buf.Reset()
		quoted = false
	}

	for i := 0; i < len(record); i++ {
		ch := record[i]
		if escaped {
			buf.WriteByte(ch)
			escaped = false
			continue
		}
		switch ch {
		case '\\':
			escaped = true
		case '"':
			inQuotes = !inQuotes
			quoted = true
		case ',':
			if inQuotes {
				buf.WriteByte(ch)
				continue
			}
			addField()
		default:
			buf.WriteByte(ch)
		}
	}

	addField()

	for i := range fields {
		if fields[i] == nil {
			continue
		}
		unescaped := unescapeAddressTypeField(*fields[i])
		fields[i] = &unescaped
	}

	if expected > 0 && len(fields) != expected {
		return nil, fmt.Errorf("expected %d fields, got %d", expected, len(fields))
	}

	return fields, nil
}

// escapeAddressTypeField escapes a composite field value.
func escapeAddressTypeField(v string) string {
	v = strings.ReplaceAll(v, "\\", "\\\\")
	return strings.ReplaceAll(v, "\"", "\\\"")
}

// unescapeAddressTypeField reverses escapeAddressTypeField.
func unescapeAddressTypeField(v string) string {
	v = strings.ReplaceAll(v, "\\\"", "\"")
	return strings.ReplaceAll(v, "\\\\", "\\")
}
