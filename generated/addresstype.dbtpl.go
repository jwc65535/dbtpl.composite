// Package generated contains generated code for schema 'public'.
package generated

// Code generated by dbtpl. DO NOT EDIT.

import (
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"fmt"
)

// AddressType is the 'address_type' composite type from schema 'public'.
type AddressType struct {
	StreetLine1 sql.NullString `json:"street_line1"` // street_line1
	StreetLine2 sql.NullString `json:"street_line2"` // street_line2
	City        sql.NullString `json:"city"`         // city
	ZipCode     sql.NullString `json:"zip_code"`     // zip_code
}

// NullAddressType represents a null 'address_type' composite for schema 'public'.
type NullAddressType struct {
	AddressType AddressType
	// Valid is true if [AddressType] is not null.
	Valid bool
}

// Value satisfies the [driver.Valuer] interface.
func (nat NullAddressType) Value() (driver.Value, error) {
	if !nat.Valid {
		return nil, nil
	}
	return nat.AddressType, nil
}

// Scan satisfies the [sql.Scanner] interface.
func (nat *NullAddressType) Scan(v any) error {
	if v == nil {
		nat.AddressType, nat.Valid = AddressType{}, false
		return nil
	}
	switch x := v.(type) {
	case []byte:
		if err := json.Unmarshal(x, &nat.AddressType); err != nil {
			return err
		}
	case string:
		if err := json.Unmarshal([]byte(x), &nat.AddressType); err != nil {
			return err
		}
	default:
		return fmt.Errorf("cannot scan %T into NullAddressType", v)
	}
	nat.Valid = true
	return nil
}

// MarshalJSON marshals [AddressType] to JSON.
func (at AddressType) MarshalJSON() ([]byte, error) {
	type alias AddressType
	return json.Marshal(alias(at))
}

// UnmarshalJSON unmarshals [AddressType] from JSON.
func (at *AddressType) UnmarshalJSON(data []byte) error {
	type alias AddressType
	return json.Unmarshal(data, (*alias)(at))
}

// Value satisfies the [driver.Valuer] interface.
func (at AddressType) Value() (driver.Value, error) {
	return json.Marshal(at)
}

// Scan satisfies the [sql.Scanner] interface.
func (at *AddressType) Scan(v any) error {
	if v == nil {
		*at = AddressType{}
		return nil
	}
	switch x := v.(type) {
	case []byte:
		return json.Unmarshal(x, at)
	case string:
		return json.Unmarshal([]byte(x), at)
	default:
		return fmt.Errorf("cannot scan %T into AddressType", v)
	}
}
